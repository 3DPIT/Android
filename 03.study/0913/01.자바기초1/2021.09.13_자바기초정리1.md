# 2021.09.13_자바기초정리1

## 1. 기술 면접 두 가지 유형

- 자바기초, 알고리즘, 자료구조등
- 내 이력서, 포트폴리오에서 사용한 기술에 대한 내용

## 2. 자바 기초 면접 질문

#### a. 객체와 클래스 차이점

- **클래스는 객체를 생성하기 위한 설계도 또는 틀** 
  - 붕어빵 틀
- **객체는 설계도 또는 틀로 찍어낸 실체**
  - 붕어빵
- 객체를 클래스의 인스턴스라고 부름
  - 객체와 인스턴스 두 용어 구별 없이 사용

#### b. 자바 기본형과 wrapper 클래스 차이점

- **wrapper 클래스**
  - 8개의 기본 데이터를 객체 형식으로 다루기 위해  JDK에 의해 지원되는 8개의 클래스
    - Byte, Short, Integer, Long, Character, Double, Float, Boolean을 통칭함
  - [-int, double등 자바 기본 데이터 타입은 클래스가 아님, 따라서 데이터 값도 객체가 아님-]]

#### c. 자바 컬렉션 종류와 차이점

- **Set**: 중복 허용안함, 순서 유지 안함
- **List**: 중복허용, 순서 유지
- 컬렉션은 가변 크기로서 객체의 개수를 염려할 필요가 없음
- 컬렉션 내의 한 객체가 삭제되면 컬렉션이 자동으로 자리를 옮겨줌
- **Vector**: List 인터페이스를 구현한 클래스
  - 가변 개수의 배열이 필요할 때 적합
  - 백터에 삽입되는 요소의 수가 많아지면 자동으로 크기가 조절됨
  - 요소는 백터의 맨 마지막이나 중간에 삽입 가능
- 무조건 동기화 
  - 성능이 많이 떨어짐, 쓸 일이 별로 없어짐 
    - 그 이유는 동기화 처리가 필요할때 (Collection, SynchronizedCollection, SynchronizedList, Map 등을 이용하는게 성능적으로 더 좋음)
- **ArrayList**: Vector클래스와 거의 동일
  - 크게 다른 점은 ArrayList는 쓰레드 간에 동기화를 지원하지 않음
    - 다수의 쓰레드가 동시에 요소를 삽입하거나 삭제 시 충돌 발생
    - ArrayList를 이용하려면 멀티 쓰레드의 동기화를 직접 구현해야함
- **HashMap<K,V>** : 키, 값의 쌍으로 구성되는 요소를 다룸
- **LinkedList**: List 인터페이스를 구현한 클래스
  - 요소들을 양방향으로 연결하여 관리한다는 점을 제외하고 Vector, ArrayList와 매우 유사
  - LinkedList는 맨 앞과 맨 뒤를 가리키는 head, tail 레퍼런스를 가지고 있음
    - 맨 앞이나 맨 뒤, 중간에 요소의 삽입이 가능하며,
    - 인덱스를 이용하여 요소에 접근 할 수도 있음

#### d. equals VS == 연산자 차이점

- **equals**: 문자열 자체를 비교
- **==연사자**: 객체의 주소값을 비교

```java
String s1 = "abc";
String s2 = new String("abc");
s1 == s2;
```

-  이때 결과값은 false
  - String s1 = "abc"는 **String Pool에서 관리**
    - 따라서 두 개의 문자열 변수를 지정했지만 JVM Heap 메모리의 String Pool에는 "abc"라는 문자열 하나만 존재
  - **new 키워드**를 사용한 두 번째 문장은, **Heap에 객체를 생성**하게 됨.
    - 같은 객체를 참조하는것이 아니기 때문에 결과는 false
    - == 연산자는 객체의 주소 값을 비교
- 위의 연산을 true로 만들려면?
  - s1.equals(s2) 해서 문자열 자체를 비교하거나
  - s2.intern() 메서드를 이용하여 string pool에 등록해서 비교하면됨

#### e. 추상화란?

- 어떤 객체를 표현함에 있어 모든 것을 다 표현하는것이 아니라 **일정 부분 특징만을 표현**
- 추상화를 하게 되면 목적을 위해 필요한 부분만을 찾을 수 있음
  - 공통된 개념과 관계에 집중할 수 있게됨

#### f. 추상 클래스란?

- 추상 메소드 를 포함하는 클래스

  - 추상메소드 : 선언은 되어 있으나 코드 구현 이 안되어있고, 껍데기만 있는것
  - abstract로 선언

- 추상 메소드가 하나도 없지만 abstract로 선언한 클래스

  #### f-a 추상 클래스의 용도

  - 추상 클래스를 상속받은 서브클래스는 개발자에 따라 다양하게 구현
    - 하지만 모든 개발자들은 서브 클래스에서 추상 클래스에 선언된 추상 메소드를 모두 구현해야함
  - 추상 클래스를 책의 목차로 비유하면, 
    - 서브 클래스는  목차에 따라 작성된 실제 책
    - 여기서 목차는 추상 클래스
  - 추상 클래스를 이용하면 응용프로그램의 설계와 구현을 분리할 수 있음
  - 추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현하면 구현 작업이 쉬워짐
    - 또한 추상 클래스는 계층적 상속 관계를 가지는 클래스들의 구조를 만들 때 적합

#### g. 인터페이스란?

- 자바의 인터페이스는 추상클래스와 유사
- 인터페이스는 규격과 같은것 
  - 따라서 인터페이스에 수정을 가할 때는 기존 인터페이스를 상속받아 새로운 인터페이스를 만듦
  - 자바에서 클래스의 다중 상속은 안됨, 인터페이스 다중 상속 가능
- 멤버는 추상 메소드(public abstract), 상수(public static final)만으로 구성
- 모든 메소드는 public이면 생략 가능
- 객체 생성 안됨
- 다른 인터페이스 상속 가능(인터페이스는 다른 인터페이스를 상속 할 수 있음)
- 인터페이스 구현 :
  - 인터페이스의 추상 메소드를 클래스에 구현하는 것 (implements 키워드)
  - 이때, 클래스는 반드시 인터페이스의 모든 추상 메소드를 구현해야 함
- 인터페이스 사용하는 이유? :
  - 사용될 클래스가 어떠한 메소드, 멤버들을 갖고 있는가에 대한 명세서와 같은 역할

#### h. 추상클래스 VS 인터페이스 차이점

| 추상 클래스                                                  | 인터페이스                |
| ------------------------------------------------------------ | ------------------------- |
| 일반 메소드 포함 가능                                        | 모든 메소드가 추상 메소드 |
| 상수 필드만 포함 가능                                        | 상수, 변수 필드 포함 가능 |
| 모든 서브 클래스에 공통된 메소드가 있는 경우에는 추상 클래스가 적합 | 다중 상속 지원            |

#### I. String Mutable 이란?

- **Immutable(가변) 객체** 

  -  객체 내의 특정 요소를 변경 할 수 있는 객체 
    - ex) List, Array List, HashMap

- **Mutable(불변) 객체**

  - 객체 내의 특정 요소의 값을 변경 할 수 있는 객체 

    - ex) String, Integer, Double, Long

  - Set 메소드 X, heap 영역에서 변경 불가라는 뜻

    ```java
    String a = "a";
    a = "b"; 
    ```

  -  위 와 같이 재할당은 가능

- **stringBuffer vs String**

  - stringBuffer는 Mutable

- **String Pool이 위치하는 영역은?**

  - Heap 영역
  - Perm 영역에서 JAVA7에서 Heap으로 바뀜
    - 이점 : string pool의 모든 문자열도 GC의 대상이 될 수 있음