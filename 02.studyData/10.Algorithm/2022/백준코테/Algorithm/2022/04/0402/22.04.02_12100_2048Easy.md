## 22.04.02_12100_2048Easy

## 01.필수 알고리즘

### 01.1 배열 회전

```c++
void rotation()
{
	int crr[N_SIZE][N_SIZE] = { 0, };
	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			crr[j][N - i -1] = board[i][j];
		}
	}

	for (int i = 0; i < N; i++) {
		for (int j = 0; j < N; j++) {
			board[i][j] = crr[i][j];
		}
	}
}
```

### 01.2 2개씩 비교해서 합치기  | 방향 오른쪽

```c++

void sumRight()
{
	for (int i = 0; i < N; i++)
	{
		vector<int>v1;
		vector<int>v2;
		for (int j = N - 1; j >= 0; j--)
		{
			if(board[i][j]!=0)
			v1.push_back(board[i][j]);
			board[i][j] = 0;
		}

		int k = 0;
		for (k = 0; k < v1.size()-1; k++)
		{
			if (v1.size() ==0)break;
			if (v1[k]!=0&&v1[k] == v1[k+1]) {
				v2.push_back(v1[k]*2);
				k++;
			}
			else 
				v2.push_back(v1[k]);
		}
		if (k == v1.size() - 1) v2.push_back(v1[k]);
		
		int index = N - 1;
		for (k = 0; k < v2.size(); k++)
		{
			board[i][index--] = v2[k];
		}
	}
}
```

- 좀 위의 경우 비효율적으로 구현한듯
  - 무엇보다 0 인경우도 걸어줘야하고 또 그냥 한개만 있는경우 한개의 데이터도 넣어야하는 소스이기떄문에 개선이 필요

## 01.3 dfs 구현

```c++