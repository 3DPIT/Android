# 2021.09.15_안드로이드2

## 1. 안드로이드 MVC 모델

- **M**odel
  - 모델은 다양한 데이터를 저장하는 역할로 SQLite를 이용한 DB
  - SharedPreference를 이용한 파일 시스템, 콘텐트 프로바이더가 있음

- **V**iew
  - 안드로이드에서 뷰는 화면에 실제 보이는 구성을 만드는 영역
    - view클래스를 상속하는 클래스를 이용하여 구성
- **C**ontroller
  - 컨트롤러는 뷰와 모델을 연결하며 제어하는 영역
    - 액티비티, 서비스, 브로드캐스트 리시버, 프래그먼트로 구성

## 2. 액티비티와 액티비티 생명 주기 

- **액티비티**
  - 안드로이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트
  - 부모 액티비티의 실행과정은
    - 첫 번째로 부모 액티비티에서 자식 액티비티를 생성 및 호출
    - 두 번째로 액티비티 매니저 서비스가 해당 앱 프로세스에서 인텐트를 복사해온 후 
      - 매니페스트 파일에서 해당 인텐트에 명시되어 있는 액티비티를 찾고 어떻게 실행할지 결정
    - 세 번째로 찾아낸 액티비티를 실행, 다시 해당 앱 프로세스에 인텐트를 복사하여 넘겨줌
    - 그 외 자식 액티비티 내의 onCreate 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게 됨
- **액티비티 상태**
  - 크게 3가지 상태가 존재
    - **실행(running)**
      - 액티비티 스택의 최상위에 있으며 포커스를 가지고 있어 사용자에게 보이는 상태
    - **일시중지(paused)**
      - 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어 포커스를 받지 못하는 상태
      - 예를 들어 대화상자가 위에 있어 일부가 가려져 있는 경우
    - **중지(stop)**
      - 다시 화면이 보이기 직전에 onRestart메소드가 호출되고 onStart메소드가 차례로 호출
      - 그 외 finish 메소드가 실행되어 해당 액티비티가 종료되기 직전에 onDestroy메소드 실행
  - 가끔 일시중지나 중지상태에서 시스템이 메모리가 부족하다고 판단 될 경우
    - onCreate메소드부터 다시 해당 액티비티를 구동
      - 이경우 onStop, onResume메소드 호출이 생략됨
    - 따라서, onSaveInstanceState, onRestoreInstanceState메소드를 이용하여,
      액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의 해줄 수 있음

## 3. 액티비티간 데이터 전달에서 임의의 클래스 객체를 바로 전달하지 못하는 이유와 전달하기 위한 처리

- 액티비티간 전달할 수 있는 데이터의 type은 보통 기본형으로 정해져 있음
  - 그 이유는 인텐트를 이용하여 액티비티의 데이터를 전달하는 과정에서 
    현재 실행중인 앱 프로세스가 시스템 프로세스로 실행중인 액티비티 매니저 서비스 프로세스에게 전달
    이 경우 프로세스간 통신이기 때문에 인텐트에 있는 값들을 복사하여 넘기는 방식으로 처리되기 때문에
    객체 주소를 바로 넘기지 못하는 문제가 발생
  - 따라서, 이 문제를 해결하기 위해 자신이 임의로 만든 클래스 객체를 전달하기 위해서는
    - Serilizable이나 Parceable 인터페이스를 상속받아 객체를 직렬화하여 넘기는 방식을 사용해야함

## 4.  부모 액티비티에서 자식 액티비티의 결과 값 받아오기

- 먼저 부모 액티비티에서 startActivityForResult 메소드를 이용하여 
  intent와 리퀘스트 코드를 파라미터로 넘김
- 이후 자식 액티비티에서 setResult메소드에 결과 코드와 데이터를 파라미터로 넘김
- 다시 부모 액티비티에서 onActivityResult메소드를 오버라이딩하여
  자식 액티비티에서 보낸 결과 코드와 데이터를 받아 처리하는 코드를 작성할 수 있음
- 이후 실행과정에서 자식 액티비티의 finish 메소드가 호출되면 부모 액티비티가 다시 화면에 나타나면서
  onResume메소드가 실행 
- 이 때, onActivityResult메소드가 작동하게됨

## 5.  서비스와 서비스 생명주기

- 서비스는 백그라운드에서 실행되는 구성 요소
  - 사용자에게 보이는 화면이 존재하지 않고, 정해지지 않은 시간 동안 운영
- 각각의 서비스는 매니페스트 파일에 서비스 태그를 이용하여 선언
- 서비스는 Service클래스를 상속받아 onStartCommand또는 onBind메소드를 재정의하여 구현할 수 있음
- 서비스는 다른 구성 요소들 처럼 메인쓰레드에서 동작
  - 따라서CPU를 많이 사용하거나 대기 상태를 필요로 하는 경우 새로운 쓰레드 생성해야함
  - 또한, 서비스의 객체는 단말에서 오직 1개만 생성되어 관리
- 먼저 서비스가 startService메소드로 실행되는 경우 서비스가 생성될 때 onCreate메소드가 실행
- 이후 서비스가 실행을 시작할 때 onStartCommand메소드가 호출되며 서비스의 상태가 실행중으로 변경
- 이후 stopService메소드가 실행되면 서비스가 종료되며, onDestory메소드를 호출하며 
  서비스의 상태가 종료로 변경
- 다음으로 서비스가 bindService메소드로 실행되는 경우 서비스가 생성될 때
  - onBind 메소드가 호출됨
  - 다음으로 unbindService 메소드가 호출되어 바인딩이 해제되면 onUnbind메소드가 호출됨
  - 이후 완전히 종료될 때, onDestroy 메소드가 호출됨

## 6. 어플리케이션과 컨텍스트

- 어플리케이션 앱 프로세스가 실행되면 가장 먼저 생성되는 객체
  - 하나의 어플리케이션 객체는 하나의 앱 프로세스와 대응됨
- 앱이 백그라운드로 내려가도 앱 프로세스는 계속 살아있기 때문에 앱 객체도 살아 있다고 할 수 있음

- 컨텍스트는 안드로이드의 컴포넌트들이 동작하기 위해 필요한 정보를 담고 있는 객체
  - 각각의 컴포넌트들(액티비티, 서비스, 브로드캐스트 리시버등)은 자신만의 컨텍스트를 가지고 있음
  - 컨텍스트 내에는 앱의 정보(패키지명 등), 컨텍스트가 실행되는 데 필요한 정보(테마 등)를 얻거나
    시스템 서비스(윈도우 매니저, 레이아웃 인플레이터 등)를 구동하는데 사용

## 7.  프레그먼트(fragment)와 프레그먼트 생명주기

- 프레그먼트는 액티비티의 일부분에만 배치되는 화면 및 동작을 조작하기 위한 객체
  - 안드로이드 3.0(허니콤....)에서 
    화면이 비교적 큰 태블릿의 등장으로 작은 단위의 화면의 생명주기 관리가 필요하여 추가
  - 프레그먼트 매니저를 통해서 여러개의 프레그먼트를 조작 할 수 있음
  - 레이아웃 xml파일에서 다른 뷰들과 함께 배치될 수 있음
- 액티비티가 생성되면 프레그먼트 매니저는 초기화(initializing)상태가 됨
- 프레그먼트가 매니저에 의해 추가되면
  - onAttach, onAttachFragment, onCreate 메소드가 차례로 실행
  - 다음으로 액티비티의 onCreate메소드 호출 이후 매니저는 생성(created)상태로 변경
  - 이때, onCreateView, onViewCreated, onActivityCreated 메소드가 차례로 호출됨
  - 다음으로 액티비티의 onStart메소드가 호출되면
    - 매니저는 시작(started)상태로 onStart메소드를 호출
    - 이후 액티비티의 onStart메소드가 호출되면 매니저 역시 재시작(resume)상태로 변함
      - onResume메소드를 호출함
    - 그 외 액티비티가 화면에서 보이지 않을 경우 호출되는 onStop메소드 호출 이후 
      - 매니저는 중지(stop) 상태가 되면 액티비티의 onDestory메소드 호출이후
        - 매니저는 onDestroyView메소드를 호출

## 8. 태스크(task)란 무엇인가?

- 어떤 앱에서 앨범 앱을 실행하는 기능이 있는 경우
  - 이 앱은 두개의 앱을 실행하는 형태가 되지만 사용자 입장에서는 하나의 앱에서 화면이 전환된다 판단
  - 이와 같은 사용자 입장에서 논리적인 화면 구성의 단위를 태스크라고 함

## 9. 안드로이드의 메모리 관리 방식

- 안드로이드는 액티비티, 서비스 리시버, 프로바이더를 실행하기 위해 앱이 실행되는 과정에서 프로세스 생성
  - 실행중인 모든 앱은 컴포넌트가 모두 종료되어도 다음에 이 앱을 다시 실행할 가능성이 높기 때문에
    프로세스를 바로 제거하지 않음
  - 바로 종료하지 않는 이유는 앱을 실행하기 위해 프로세스를 생성하는 과정에서 딜레이가 발생하는데,
    이 딜레이를 줄이기 위함
  - 따라서, 사용자에 의해 다시 앱이 실행되면 남아있던 프로세스가 존재하는 경우 바로 실행됨
- 이 과정에서 쌓여있던 많은 프로세스로 인해 메모리가 부족해지는 경우 
  - 프로세스의 우선순위(사용빈도)에 따라 프로세스를 종료하여 메모리를 확보

## 10. NDK 에서 로그캣(logcat)에 로그를 출력

- android/log.h를 import한후 `__android_log_print`메소드를 호출하여
  NDK환경에서 로그캣에 로그를 출력할 수 있음

````c++
#include <android/log.h>
...
__android_log_print(ANDROID_LOG_VERBOSE, "com.example", "hello world!", 1);
````