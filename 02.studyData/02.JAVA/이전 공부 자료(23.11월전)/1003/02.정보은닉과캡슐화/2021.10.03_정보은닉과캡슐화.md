## 2021.10.03_정보은닉과 캡슐화

### 09-1 정보은닉

- 클래스가 있고 그걸로 생성한 인스턴스가 있다고 할때 
  - 이 두개는 같은 것이다. 즉, 성격이 같다.
- 클래스는 데이터와 기능으로 구성되어 있음
  - 데이터 : 변수
  - 기능 : 메소드 
- 정보은닉의 핵심은 인스턴스의 외부접근을 허용하지 않겠다임
- 클래스가 주체 내부에서만 접근하게 하겠다.
- 대신 기능인 메소드를 이용해서 데이터인 변수의 접근을 허용한다는 것
- 이처럼 메소드를 이용해서 접근하면 안정성이 높아진다.

### 여기서 문제는

- private선언을 하면 정보은닉이 되는데 우리가 멤버에 직접접근을 하면 

  이를 막을 방법이 없다.

- 여기서 더 큰 문제는 이 논리적오류는 문법적 오류가 아니기 때문에 컴파일 오류가 안생김

  - 그래서 진짜 제대로 동작은 하는데 결과가 이상하게 나오는 경우가 생김

- 그래서 이 논리적 오류를 문법적 오류로 만드는것

  - 정보은닉이라고함

- 선언을 위에 말했듯이 private라고 써주면됨

## 09-2 접근수준지시자

## 종류

- public
  - 어디서든 접근이 가능함
  - 값을 가져가기 위한 Getter메소드와
  - 값을 저장 또는 수정하기 위한 Setter메소드를 가지는것이 보편적임
- protected
- default
- private
  - 클래스 내부에서만 접근허용
  - 외부접근 허용하지 않음

## protected, default

- 쉽게 설명하면 private에서 한군데 더 접근권한 갖는것 default (private +1)
- 거기에 한군데 더 접근권한 갖는것 protected (private+2)

## default

- 동일 패키지로 묶인 클래스 내에서만 인스턴스 생성을 허용

## protected

- 동일 패키지가 아닌 상황에 상속되어 있는 경우라고 해보자

```java
package AAA;
public class AAA{
  int num;
}
------------------------
public class ZZZ extends AAA{
  public void init(int n){
		num = n;
  }
}
```

- 이 두개 클래스는 현재는 같은 위치에 있어 보이나 다른 위치에 있다고 가정하자.
- 우선 AAA는 public이기도 하고 다른 패키지 이지만 상속은 가능하다.
- 여기서 

```java
package AAA;
public class AAA{
 protected int num;
}
```

- 이렇게 해줘야 상속관계에 있는 경우 접근 허용이 가능해진다. 

## 09-3 캡슐화

- car라는 것이 있을때 이를 적절히 담아내는 것
- 역할에 따라 다름

## 코감기에 대한 클래스 

- 코감기가 콧물, 재채기, 코막힘을 동반한다고 하자.
- 이때 약의 복용순서가 중요하고 이 복용순서 위배가 되면 안된다고 할 때,
- 그대로 구현을 했을때는,
- 3개의 클래스 정보를 알고 있어야 하고 우리는 복용 순서도 알고 있어야 한다.
- 캡슐화는 위와 같이 복잡하면 안된다. 즉 인스턴스 생성이 쉬워야한다. 
- 위의 경우 인스턴스 생성을 3번을 해야하고 정보를 많이 알고 있어야하는 단점이 있음

## 캡슐화 방법

- 새로운 클래스 생성해서
  - 3개의 치료약의 메소드가지고 있고,
  - 1개의 복용방법인 메소드(take())로 복용순서를 미리 구현해놓으면
- 우리는 이때 인스턴스를 하나생성하고,  take()로만으로 문제가 해결이 가능하다.
- 즉, 3가지 알아야 했던 것이 한개의 클래스만으로 단순해지고, 정보가 적거나 모르더라도 사용이 편해짐