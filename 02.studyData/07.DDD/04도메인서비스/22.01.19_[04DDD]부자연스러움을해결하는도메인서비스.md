## 22.01.19_[04DDD]부자연스러움을해결하는도메인서비스

- 도메인 개념을 녹이고 값 객체나 엔티티의 행동으로 구현하려면 어딘가 어색한 부분이 생기는 경우가 있음
  - 이 어색한 느낌은 특히 도메인에서 일어나는 활동을 코드로 옮겼을때 자주 나타남
  - 어색한 것을 해결하지 않고, 값 객체의 행동을 억지로 구현하면 객체의 책임이 왜곡될 수 있음
- 해결책은 어색한 느낌을 낳는 이 행동을 별도의 객체로 분리해 정의하는 것
  - 그것이 도메인 서비스이다.

## 1. 서비스란?

- 소프트웨어 개발에서 말하는 서비스는 클라이언트를 위해 무언가를 해주는 객체를 말함
  - 너무 광범위하기도 하고 도메인 주도 설계에만 초점을 맞춰도 서비스가 들어간 용어끼리 의미가 서로 다른 경우도 있어서 상당히 큰 혼란을 야기한다.

### 1.1 도메인 주도 설계에서 말하는 서비스

- 크게 두가지로 나뉜다.
- **첫 번째** 도메인을 위한 서비스
- **두 번째** 애플리케이션을 위한 서비스
  - 서비스의 의미가 혼란스러운 이유는 위 두 가지를 혼동하기 때문

## 2. 도메인 서비스란?

- 값 객체나 엔티티 같은 도메인 객체에는 객체의 행동을 정의 할 수 있음
  - 예를 들면 사용할 수 있는 문자열의 길이나 문자의 종류에 제한이 있다면 
    - 이러한 지식은 사용자명을 나타내는 값객체에 정의 될 것

-  그러나 시스템에는 값 객체나 엔티티로 구현하기 어색한 행동이 있음
  - 도메인 서비스는 이런 어색함을 해결해주는 객체

### 2.1 값 객체나 엔티티에 정의하기 어색한 행동이란?

- 현실에서는 동명이인이 충분히 있을 수 있음
  - 하지만, 시스템에서는 사용자명을 중복으로 사용할 수 없게 하는 경우는 많음
- 사용자명에 중복을 허용하지 않는 것은 도메인의 규칙이고,
  - 따라서 도메인 객체에 행동으로 정의돼야 함

#### 2.2.1 사용자명의 중복여부 확인하는 코드 User클래스에 추가

```c#
class User
{
    private readonly UserId id;
    private UserName name;
    
    public User(UserId id, UserName name){
        if(id == null) throw new ArgumentNullException(nameof(id));
        if(name == null) threow new ARgumentNullException(nameof(id));
        
        this.is = id; 
        this.name = name;
    }
    
    //사용자명 중복 여부 확인 코드 추가
    public bool Exists(User user)
    {
        //사용자명 중복을 확인하는 코드
        //생략
    }
}
```

- 여기서 중요한 것은 중복을 확인하는 수단이 User클래스의 행동으로 정의돼 있다는 것
- 객체의 정의만 보면 문제가 없으나, 위 코드는 자연스럽지는 않음

#### 2.2.2 위의 2.2.1를 사용한 사용자명 중복 확인

```c#
var userId = new UserId("id");
var userName = new UserName("smith");
var user = new User(userId, userName);

//새로만든 객체에 중복 여부를 묻는 상황이 됨
var duplicateCheckResult = user.Exists(user);
Consol.WriteLine(duplicateCheckResult); // true? false;
```

- 위 처럼 사용자명 중복을 확인하는 처리는 User 클래스에 정의돼 있어서
  - 결국 자기 자신에게 중복 여부를 묻는 상황이 됨
  - 중복 여부 확인을 새로 생성한 객체에 맡기면 개발자가 혼란을 일으키기 쉬움
    - 사용자명 중복을 확인하는 목적으로만 사용되는 전용 인스턴스를 만들어보면 더좋을것 같음ㄴㄴ

