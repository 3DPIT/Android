## 22.01.14_값객체란?

## 1.값객체란?

- 시스템 특유의 값을 표현 하기 위해 정의하는 객체를 값 객체
  - 프로그래밍 언어에는 원시 데이터 타입이 있음
  - 원시데이터 타입만 사용해 시스템을 개발할 수 있으나 때로는 특유의 값을 정의해야 할 때가 있음

### 1.1 원시데이터 값으로 성명 표현

```c#
var fullName = "naruse mananobu";
Console.WriteLine(fullName);// naruse mananobu 값이 출력됨
```

- 성만 출력하고 싶거나, 성과 이름 순으로 출력하고 싶은 다양한 요구사항이 있는 경우에 아래와 같이 우선 성씨만 출력하는 경우이다.

### 1.2 이름 중 성씨만 출력

```c#
var fullName = "naruse mananobu";
var tokens = fullName.Split(' ');// ["naruse", "mananobu" ] 배열이됨
var lastName = tokens[0];
console.WriteLine(lastName);// naruse 가 출력됨
```

- 위가 제대로 동작한다고 생각이 들 수 있지만 이름을 쓰는 관습에 따라서 
  - 실제 성은 smith인데 성씨를 뒤에 쓰는 관습에 따라서 john smith라고 쓴다면
  - 위의 코드에 적용이 된다면 이름이 john이 출력이 되기 때문에 제대로 동작하지 않을 수 있음

## 2.이를 해결하기 위한 방법

- 대개 객체지향 프로그래밍에서는 클래스를 사용함

### 2.1 클래스로 만들기

```c#
Class FullName
{
    public FullName (string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
    
    public string FirstName { get; set; }
    public string LastName  { get; set; }
}
```

#### 2.1.1 FullName 클래스의 LastName 프로퍼티 사용

```c#
var fullName = new FullName("masanobu", "naruse");
Console.WriteLine(fullName.LastName); // naruse가 출력
```

- 시스템에서 어떤 처리를 해야 하는지에 따라 값을 나타내는 표현이 정해짐
- FullName 클래스는 이 시스템의 필요에 맞는 성명을 나타내는 표현
  - 객체이기도 하고 동시에 값이기도함
    - 이를, 값 객체라고 함

![image-20220114082940647](22.01.14_값객체란.assets/image-20220114082940647.png)

## 3.값의 성질과 값 객체의 구현

- 값에도 일정한 성질이 있음
  - 이 값의 성질이 값 객체를 이해하는 열쇠

### 3.1 값의 설질 대표적 세가지

- 변하지 않음
- 주고받을 수 있음
- 등가성을 비교할 수 있음

### 3.2 값의 불변성

```c#
var greet = "안녕하세요";
Console.WriteLine(greet); // 안녕하세요 출력됨
greet = "Hello";
Console.WriteLine(greet); // Hello가 출력됨
```

- 위에 처럼 값을 수정할 수 있다고 보편적으로 생각함
  - 하지만 우리가 값을 수정할 때는 새로운 값을 대입
  - **대입은 값을 수정하는 과정이 아님**
    - 대입을 통해 수정되는 것은 변수의 내용이고, 값 자체가 수정되는것 아님

#### 3.2.1 값을 수정하는 의사 코드

```c#
var greet = "안녕하세요";
greet.ChangeTo("Hello"); // 실제로는 이런 메소드 없음
Console.WriteLine(greet); // Hello가 출력됨
```

- 이해가 안된다고 하더라도 위와 같은것이 허용이 되면 아래와 같은 경우도 허용한다는 소리

```c#
"안녕하세요".ChangeTo("Hello"); 
Console.WriteLine("안녕하세요"); // Hello가 출력됨
```

- 이런것이 허용이 되면 개발자들은 혼란스러울 것
- 즉, 위와 같이 값을 수정한다면 안심하고 값을 사용 할 수 없음
  - 결론, 1이라는 숫자가 갑자기 0이 되면 안되고, 1이라는 숫자는 항상 1이어야 하는 것처럼 값은 변하지 않는다는 것임

#### 3.2.2 일반적으로 볼 수 있는 값 수정

```c#
var fullName = new FullName("masanobu", "naruse");
fullName.ChangeLastName("sato");
```

- 대부분 개발자 입장에서는 자연스러움
  - 그러나, FullName 클래스를 값으로 간주할 경우 부자연스러움
- FullName은 시스템 특유의 값을 표현하는 값 객체
  - FullName도 값이기도함
  - 그래서 변하지 않아야함
  - 즉, FullName 클래스에 값을 수정하는 기능을 제공하는 ChangeLastName같은 메서드가 정의되면 안됨

### 3.3 교환가능하다

- 값은 불변일지라도 값을 수정할 필요는 있음

#### 3.3.1 평소 값을 수정하는 방식

``` c#
// 숫자값 수정
var num = 0;
num = 1;

// 문자값 수정
var c = '0';
c = 'b';

// 문자열값 수정
var greet = "안녕하세요";
greet = "hello";
```

- 모두 변수에 값을 대입하는 코드
- 즉, 대입문 자체가 값의 수정을 나타내는 방법
  - 값이든 값객체든 그 값자체를 수정하면 안되지만 대입문을 통해 교환의 형식으로 표현됨

#### 3.3.2 값 객체를 수정하는 방법

```c#
var fullName = new FullName("masanobu", "naruse");
fullName = new FullName("masanobu", "sato");
```

![image-20220114085041541](22.01.14_값객체란.assets/image-20220114085041541.png)

## 3.4 등가성 비교 가능

- 같은 종류의 값끼리는 비교할 수 있음

```c#
Console.WriteLine(0 == 0);
Console.WriteLine('a' == 'b');
Console.WriteLine( "hello" == "hello");
```

- 표현식 0 == 0에서 좌변의  0과 우변의 0은 인스턴스로서는 별개의 존재이지만 
  - 같은 값으로 취급됨
- 값은 값 자신이 아니라 값을 구성하는 속성을 통해 비교된다는 점
- 값 객체도 값 객체를 구성한느 속성(인스턴스 변수)을 통해 비교됨

### 3.4.1 값 객체 간의 비교

```c#
var nameA = new FullName("masanobu", "naruse");
var nameB = new FullName("masanobu", "naruse");

// 두 인스턴스를 비교
Console.WriteLine(nameA.equals(nameB)); // 인스턴스를 구성하는 속성이 같아서 true
```

### 3.4.2 속성값을 꺼내 직접 비교하기

```c#
var nameA = new FullName("masanobu", "naruse");
var nameB = new FullName("john", "smith");

var compareResult = nameA.FirstName == nameB.FirstName &&
                    nameA.LastName == nameB.LastName;
Console.WriteLine(compareResult);
```

- 언뜻보면 자연스러운 코드 같지만 FullName 객체가 값이라는 사실을 생각하면 부자연스러운 코드임

#### 속성을 꺼내 직접 비교하는 방식을 숫자에 적용한 코드

```c#
Console.WriteLine(1.Value == 0.Value); //false?
```

- 위와 같은 코드는 본적이 없을 것 값의 값을 꺼낸다는 것은 자연스러운것이 아님
- 값 객체는시스템 고유의 값임, 결국 값
  - 따라서, 값의 속성을 꺼내 비교하는 것이 아니라, 값과 마찬가지로 직접 값끼리 비교하는 방식이 자연스러움

### 3.4.3 값끼리 직접 비교하기

```c#
var nameA = new FullName("masanobu", "naruse");
var nameB = new FullName("jhon", "smith");

var compareResult = nameA.equals(nameB);
Console.WriteLine(compareResult);

// 연산자 오버라이드를 활용할 수도 있음
var compareResult2 = nameA == nameB;
Console.Write(compareResult2);
```

- 위 처럼 자연스러운 코드를 사용하려면 값 객체를 비교하는 매서드를 제공해야 함

#### 비교 메서드를 제공하는 FullName 클래스

```c#
class FullName : IEquatable<FullName>
{
    public FullName(string firstName, string lastName)
    {
        FirstName = firstName;
        LastName = lastName;
    }
    public string FirstName {get;}
    public string LastName {get;}
    
    public bool Equals(FullName other)
    {
        if(ReferenceEquals(null, other)) return false;
        if(ReferenceEquals(this, other)) return true;
        return string.Equals(FirstName, other.FirstName)
            && string.Equals(LastName, other.LastName);
    }
    
    public override bool Equals(object obj)
    {
        if(ReferenceEquals(null, obj)) return false;
        if(ReferenceEquals(this, obj)) return true;
        if(obj.GetType() != this.GetType()) return false;
        return Equals((FullName) obj);
    }
    // C#에서 Equals를 오버라이드하려면 GetHashCode를 함께 오버라이드해야 한다.
    public override int GetHashCode()
    {
        unchecked
        {
            return ((FirstName != null ? FirstName.GetHashCode() : 0) * 397)
                ^ (LastName != null ? LastName.GetHashCode() : 0);
		}
	}
}
```

- 위의 코드가 C#에서 비교를 구현하는 전형적인 코드
- 두 값 객체를 비교하려면 값 객체의 속성을 꺼내 비교하는 대신 Equals 메서드를 쓰면 됨
  - 위의 방법으로 값 객체도 값과 같은 방법으로 비교할 수 있음

> `객체를 비교하는 코드를 자연스럽게`  만든다는 목적만으로 이만큼의 코드를 작성하는 게 찜찜할 수 있지만 위의 경우는 명확한 장점이 있음
>
> - 값 객체에 인스턴스 변수를 추가할 때 이 장점을 알 수 있음

## 4.속성을 추가해도 수정이 필요 없음

- 성과 이름 사이에 미들네임이 있는 경우
- 이 미들네임을 표현하기 위해 FullName 클래스에 속성을 추가해야 하는 상황이라면?
  - 값 객체에 비교를 위한 메서드가 없어서 코드에서 속성을 직접 꺼내 비교해야 할 경우, 새로 추가된 속성이 생겼을때 비교하는 코드를 모두 수정해야함

### 4.1 속성을 직접 비교할 경우 새로운 속성 추가하기

```c#
var compareResult = nameA.FirstName == nameB.FirstName && nameA.LastName == nameB.LastName && nameA==MiddleName == nameB.MiddleName;
// 위에 처럼 조건식이 추가됨
```

- 한 곳의 경우 그냥 고칠 수 있지만 여러 곳인 경우는 수정이 어렵다
- 그래서 값 객체에서 직접 비교 수단을 제공하면 단순하고 지루한 작업을 피할 수 있음
- **Before**

```c#
class FullName : IEquatable<FullName>
{
... 
    public bool Equals(FullName other)
    {
        if(ReferenceEquals(null, other)) return false;
        if(ReferenceEquals(this, other)) return true;
        return string.Equals(FirstName, other.FirstName)
            && string.Equals(LastName, other.LastName);
    }    
   ...
}
```

- **After**

```c#
class FullName : IEquatable<FullName>
{
... 
    public bool Equals(FullName other)
    {
        if(ReferenceEquals(null, other)) return false;
        if(ReferenceEquals(this, other)) return true;
        return string.Equals(FirstName, other.FirstName)
            && string.Equals(LastName, other.LastName)
            && string.Equals(MiddleName, other.MiddleName);// 이곳의 조건식만 추가하면 됨
    }    
   ...
}
```

- 즉, 다른 새로운 속성이 추가되더라도
  - 수정할 곳은 Equals메서드 내부로 제한됨
  - 비교뿐만 아니라 값의 속성을 다루는 처리 역시 값객체에서 제공하게 하면 수정할 곳을 줄일 수 있음

## 5. 값 객체가 되기 위한 기준

- FullName 클래스를 구성하는 firstName이나 lastName등의 속성은 값 객체가 아니라 원시타입인 문자열로 정의돼 있음

-  가능한 모든 속성을 값 객체로 만든 FullName크ㄹ래스

  ```c#
  class FullName : IEquatable<FullName>
  {
      private readonly FirstName firstName;
      private readonly LastName lastName;
      
      public FullName(FirstName firstName, LastName lastName){
          this.firstName = firstName;
          this.lastName = lastName;
      }
      //(생략)
  }
  ```

- 생성자 메서드에 전달되는 인자는 값 객체

  - 이름을 나타내는 값 객체

    ```c#
    class FullName : IEquatable<FullName>
    {
    ... 
        public bool Equals(FullName other)
        {
            if(ReferenceEquals(null, other)) return false;
            if(ReferenceEquals(this, other)) return true;
            return string.Equals(FirstName, other.FirstName)
                && string.Equals(LastName, other.LastName);
        }    
       ...
    }
    ```

  - 성을 나타내는 값 객체

    ```c#
    class LastName
    {
    	private readonly string value;
        
        public LastName(string value)
        {
            if(stirng.IsNullOrEmpty(value)) throw new ArgumentException("최소 1글자 이상 이어야함", nameof(value));
            
            this.value = value;
        }
    }
    ```

- 이책에서 개인적인 기준

  - 도메인 모델로 선정되지 못한 개념을 값 객체로 정의해야 할 지에 대한 기준으로 
    - **규칙이 존재하는가?**
    - **낱개로 다루어야 하는가?** 
      - 두개를 중점으로 생각

  - 성명을 예로 들면 

    - 규칙
      - 성과 이름으로 구성됨

    - 낱개
      - 앞서 본문에서 봤듯이 낱개로 다뤄지는 정보

    - 즉, 위의 상황으로 봐서 성명은 값 객체로 정의 해야 할 개념이 됨

  - 성 혹은 이름 

    - 현재라면 값 객체로 만들지 않을것
    - 단, 전제를 바꿔 성과 이름에서 사용가능한 문자에 제약이 있으면?
      - 결론적으로 값 객체로 정의하지 않고도 규칙을 ㅇ제 할 수 있음

  ```c#
  class FullName : IEquatable<FullName>
  {
      private readonly FirstName firstName;
      private readonly LastName lastName;
      
      public FullName(string firstName, string lastName)
      {
          if(firstName == null) throw new ArgumentNullException(nameof(firstName));
          if(lastName == null) throw new ArgumentNullException(nameof(lastName));
          if(!ValidateName(firstName)) throw new ArgumentException("허가되지 않은 문자가 사용됨", nameof(firstName));
          if(!ValidateName(lastName)) throw new ArgumentException("허가되지 않은 문자가 사용됨", nameof(lastName));
          
          this.firstName = firstName;
          this.lastName = lastName;
  	}
      
      private bool ValidateName(string value)
      {
          //사용가능한 문자를 알파벳으로 제한
          return Regex.IsMatch(value, @"^[a-ZA-Z]+$");
  	}
      //(생략)
  }
  ```

  - 위에 처럼FullName 클래스속성이 원시타입이어도 인자를 전달받은 시점에 검사를 하면 규칙을 강제할 수 있음
  - 값객체로 정의해도 문제는 없음
    - 만약 값객체로 만들기로 했다면, 성과 이름을 별도의 타입으로 나눌지 말지 선택
    - 따로 다룰 필요가 없는 경우 하나의 타입으로 다룰 수 있음

  - **이름을 나타내는 클래스**

    ```c#
    class Name
    {
        private readonly string value;
        
        public Name(string value)
        {
            if(value == null) throw new ArgumentNullException(nameof(value));
            if(!Regex.IsMatch(value, @"^[a-zA-Z]+$")) throw new ArgumentException("허가 되지 않은 문자가 사용됨", nameof(value));
            
            this.value = value;
        }
    }
    ```

  - **Name클래스를 이용해 구현한 FullName 클래스**

    ```c#
    class FullName
    {
        private readonly Name firstName;
        private readonly Name lastName;
        
        public FullName(Name firstName, Name lastName)
        {
            if(firstName == null) throw new ArgumentNullException(nameof(firstName));
            if(lastName == null) throw new ArgumentNullException(nameof(lastName));
            
            this.firstName = firstName;
            this.lastName = lastName;
            //(생략)
        }
    }
    ```

## 6. 행동이 정의된 값 객체

- 값 객체에서 중요한 점 중 하나는 독자적인 행위를 정의할 수 있다는 점

- 돈에는 액수와 화폐 단위 2가지 속성

  ```c#
  class Money
  {
      private readonly decimal amount;
      private readonly string currency;
      
      this.amount = amount;
      this.currency = currency;
  }
  ```

  - 값 객체는 데이터만을 저장하는 컨테이너가 아니라 행동을 가질 수도 있는 객체



