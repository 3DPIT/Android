## 22.02.26_3.데이터형식

## 1.데이터 형식

![image-20220226145741289](22.02.06_3.데이터형식.assets/image-20220226145741289.png)

- 기본 데이터 형식
  - 상수, 열거형
- 복합 데이터 형식
  - 구조체와 클래스, 배열

![image-20220226145929155](22.02.06_3.데이터형식.assets/image-20220226145929155.png)

- **값 형식과 스택**
- 값 형식은 변수가 값을 담는 데이터 형식
  - 스택 형식은 자신이 담고 있던 데이터가 쓰레기 되지 않게 수거함

![image-20220226150158447](22.02.06_3.데이터형식.assets/image-20220226150158447.png)

![image-20220226150210788](22.02.06_3.데이터형식.assets/image-20220226150210788.png)

-  코드 블록과 상관없이 데이터 유지하고 싶을때 스택의 구조가 발목을 잡음



-  **참조형식과 힙**

- 참조형식은 변수가 값 대신 값이 있는 곳의 위치를 담는 데이터 형식
  - 힙은 저장된 데이터를 스스로 제거하는 메커니즘을 갖고 있지 않음
    - 그대신 청소부를 따로 고용 그것이 CLR의 가비지 컬렉터
  - 힙영역은 데이터를 저장하고 스택영역에 데이터가 저장된 힙 메모리 주소를 저장
    - 그래서 참조형식이라고함
    - 즉, 데이터를 직접 저장하는 대신 실제 데이터가 저장된 메모리의 주소를 참조한다고 해서 참조 형식

- 참조형식은 변수가 값 대신 값이 있는 곳의 위치를 담는 데이터 형식

![image-20220226150738064](22.02.06_3.데이터형식.assets/image-20220226150738064.png)

## 2.박싱과 언박싱

![image-20220226151048884](22.02.06_3.데이터형식.assets/image-20220226151048884.png)

![image-20220226151029232](22.02.06_3.데이터형식.assets/image-20220226151029232.png)

- 여기서 a는 20이 박싱 되어 저장된 힙을 참조
- b는 a가 참조하고 있는 메모리로 부터 값을 복사하려고 하는것
  - 이때 박싱된 값을 꺼내 값 형식변수로 저장하는 과정 언박싱

## 3.Nullable 형식

- 대게 int형식 변수를 선언하면 0이 기본적으로 들어가는데

- 가끔 어떤 값도 가지지 않는 변수가 필요할 때가 있음

  - 0이 아닌 null인 비어있는 값 

- Nullable은 형식의 이름 null (비어있는) + able(~될수 있는)

  - 즉, 비어있는 상태가 될수 있는 형식이라는 것

  ![image-20220226151555003](22.02.06_3.데이터형식.assets/image-20220226151555003.png)

- Nullable 형식은 HasValue와 Value 두가지 속성을 갖고 있음
  - HasValue속성은 해당 변수가 값을 갖고 있는지 또는 그렇지 않은지 나타내는것
  - Value 속성은 변수가 담겨있는 값

![image-20220226151818458](22.02.06_3.데이터형식.assets/image-20220226151818458.png)

## 4.문자열 보간

- C# 6.0에서 도입된 기능
- 보간 이라는 낱말은 비거나 누락된 부분을 채운다는 뜻

![image-20220226151959793](22.02.06_3.데이터형식.assets/image-20220226151959793.png)





## 6.메소드 오버로딩

- 오버로딩 과적하다
  - 과적이란 트럭따위에 원래의 탑재량을 넘겨 싣는 것
  - 하나의 메소드 이름에 여러 개의 구현을 올리는 것

## 6.1 명명된 인수

![image-20220226152919302](22.02.06_3.데이터형식.assets/image-20220226152919302.png)

## 6.2 선택적 인수

![image-20220226153008478](22.02.06_3.데이터형식.assets/image-20220226153008478.png)

## 7.클래스

- 클래스 선언

![image-20220226153741777](22.02.06_3.데이터형식.assets/image-20220226153741777.png)

![image-20220226154510119](22.02.06_3.데이터형식.assets/image-20220226154510119.png)

- 생성자는 객체가 생성될때 생성자가 호출
- 종료자는 호출되고 소멸할 때 종료자가 호출

### 7.1 생성자

![image-20220226154720283](22.02.06_3.데이터형식.assets/image-20220226154720283.png)

![image-20220226154740137](22.02.06_3.데이터형식.assets/image-20220226154740137.png)

- 사실 명시적으로 구현하지 않아도 컴파일러가 생성자 만들어줌

  - 이런 생성자를 기본 생성자라고함

- 왜 만들어야하나?

  - 객체를 다루다 보면 객체를 생성하는 시점에 객체의 상태
    - 즉, 객체의 필드를 원하는 값으로 초기화 하고 싶은 경우

  ![image-20220226154920246](22.02.06_3.데이터형식.assets/image-20220226154920246.png)

### 7.2 종료자

- 종료자의 이름은 클래스 이름 앞에 ~를 붙인 꼴
  - 종료자는 생성자와 달리 매개변수도 없고 한정자도 사용하지 않음
  - 그렇다고 해서 여러 버전의 종료자를 만드는 오버로딩 불가능
    - 직접호출 안됨
- 사용은? 
  - CLR의 가비지 컬렉터가 객체가 소멸되는 시점을 판단해서 종료자를 호출
  - CLR의 가비지 컬렉터가 언제 동작할지 예측하기도 힘들어 가급적 사용 안하는게 좋음

### 7.3 정적필드와 메소드

- static은 사전적으로 정적이라는 뜻
  - 움직이지 않는다는 뜻
- C#에서 static은 메소드나 필드가 클래스의 인스턴스가 아닌 클래스 자체에 소속되도록 지정하는 한정자

![image-20220226155619794](22.02.06_3.데이터형식.assets/image-20220226155619794.png)

- 필요한것은 프로그램 전체에 걸쳐 공유해야하는 변수가 있다면 정적 필드를 이용하면됨

![image-20220226160112806](22.02.06_3.데이터형식.assets/image-20220226160112806.png)

![image-20220226160140822](22.02.06_3.데이터형식.assets/image-20220226160140822.png)

- 2번이 결과로 나옴
  - 그것은 참조형식이기 때문임

![image-20220226160339695](22.02.06_3.데이터형식.assets/image-20220226160339695.png)

![image-20220226160538544](22.02.06_3.데이터형식.assets/image-20220226160538544.png)

![image-20220226160659129](22.02.06_3.데이터형식.assets/image-20220226160659129.png)

![image-20220226160714109](22.02.06_3.데이터형식.assets/image-20220226160714109.png)

![image-20220226160735387](22.02.06_3.데이터형식.assets/image-20220226160735387.png)

![image-20220226160809096](22.02.06_3.데이터형식.assets/image-20220226160809096.png)

### 7.5 this

![image-20220226160840885](22.02.06_3.데이터형식.assets/image-20220226160840885.png)

#### 7.5.1 this()생성자

![image-20220226161006074](22.02.06_3.데이터형식.assets/image-20220226161006074.png)

![image-20220226161018991](22.02.06_3.데이터형식.assets/image-20220226161018991.png)

### 7.6 접근한정자

![image-20220226171727489](22.02.06_3.데이터형식.assets/image-20220226171727489.png)

- 접근 한정자로 수식하지 않은 클래스의 멤버는 무조건 private로 지정됨

![image-20220226161232999](22.02.06_3.데이터형식.assets/image-20220226161232999.png)

### 7.7 상속으로 코드 재활용

- 객체지향에서 물러받는 클래스
  - 파생클래스, 자식 클래스
- 물려줄 클래스
  - 기반 클래스, 부모 클래스

![image-20220226161353290](22.02.06_3.데이터형식.assets/image-20220226161353290.png)

![image-20220226161458545](22.02.06_3.데이터형식.assets/image-20220226161458545.png)

- 파생 클래스의 생성 과정을 통해 보면

  - 파생 클래스는 객체를 생성할 때 내부적으로 기반 클래스 호출 후 자신의 생성자 호출하고 객체가 소멸될 때는 반대의 순서대로
    - 파생클래스 -> 기반 클래스 종료자 호출

- **생성자 넘겨주기**

  ![image-20220226161643230](22.02.06_3.데이터형식.assets/image-20220226161643230.png)

- 파생 클래스의 생성자에서 기반 클래스의 생성자로 매개변수 넘겨주는 법
  - this와 동일
  - base() 라고 쓰고 매개변수 넘겨서 호출하면 우리가 원했던 것처럼 
    - Base()생성자를 통해 Name 필드를 초기화 할 수 있음

![image-20220226161931002](22.02.06_3.데이터형식.assets/image-20220226161931002.png)

![image-20220226161956054](22.02.06_3.데이터형식.assets/image-20220226161956054.png)

### 7.8 기반 클래스와 파생 클래스 사이의 형식 변환 

- 개와 고양이는 종이 다르지만 젖을 먹인다는 공통점으로 포유류로 분류

![image-20220226162109494](22.02.06_3.데이터형식.assets/image-20220226162109494.png)

![image-20220226162138615](22.02.06_3.데이터형식.assets/image-20220226162138615.png)

- 파생 클래스의 인스턴스는 기반 클래스 인스턴스로 사용 할수 있는것
  - 무슨 의미가 있냐면 코드의 생산성이 높아짐$

![image-20220226162300178](22.02.06_3.데이터형식.assets/image-20220226162300178.png)

- C#은 형식 변환을 위해 아주 멋진 연산자 두개를 제공
  - 그것이 is as 

![image-20220226162404776](22.02.06_3.데이터형식.assets/image-20220226162404776.png)

![image-20220226162427538](22.02.06_3.데이터형식.assets/image-20220226162427538.png)

### 7.9 오버라이딩과 다형성

- 다형성은 객체가 여러 형태를 가질 수 있음을 의미
  - 즉 자신으로 부터 상속 받아 만들어진 파생 클래스를 통해 다형성 실현한다는것

![image-20220226162542344](22.02.06_3.데이터형식.assets/image-20220226162542344.png)

![image-20220226162605702](22.02.06_3.데이터형식.assets/image-20220226162605702.png)

![image-20220226162629725](22.02.06_3.데이터형식.assets/image-20220226162629725.png)

### 7.10 메소드 숨기기

- 기반 클래스에서 구현된 버전의메소드를 감추고 파생 클래스에서 구현된 버전만 보여주는 것
- ![image-20220226162836424](22.02.06_3.데이터형식.assets/image-20220226162836424.png)

### 7.11 오버라이딩 봉인

- 상속이 안되게 하는 것
- sealed 키워드 이용함

![image-20220226162951139](22.02.06_3.데이터형식.assets/image-20220226162951139.png)

### 7.12 읽기 전용 필드

- 상수와 변수 그 중간 어딘가임
- 읽기만 가능한 필드
  - 즉, 클래스나 구조체의 멤버로만 존재할 수 있으며 생성자 안에서 한번 값을 지정하면 그 이후로 값 변경 불가

![image-20220226163128113](22.02.06_3.데이터형식.assets/image-20220226163128113.png)

### 7.13 중첩 클래스

![image-20220226163158262](22.02.06_3.데이터형식.assets/image-20220226163158262.png)

- 쓰는 이유
  - 클래스 외부에 공개하고 싶지 않은 형식을 만들고자 할 때
  - 현재 클래스의 일부분처럼 표현할 수 있는 클래스를 만들고자 할때

### 7.14 분할 클래스

- 클래스를 여러번에 나눠서 구현하는 클래스

  ![image-20220226163316881](22.02.06_3.데이터형식.assets/image-20220226163316881.png)

### 7.15 확장 메소드

- 기존 클래스의 기능을 확장하는 기법

  - 이것을 이용하면 string 클래스에 문자열을 뒤집는 기능이나 int 형식에 제곱 연산 기능을 넣을 수 있음

  

![image-20220226163543197](22.02.06_3.데이터형식.assets/image-20220226163543197.png)

![image-20220226163603166](22.02.06_3.데이터형식.assets/image-20220226163603166.png)