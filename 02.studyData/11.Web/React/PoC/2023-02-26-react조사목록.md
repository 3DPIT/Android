```
## 할일
Reactquery -> 이거 깊은 수준의 POC 필요합니다.
Zulstands -> 이거 깊은 수준의 POC 필요합니다.
Hook -> 구글링해서 store Object Change Hook 이거 만들어보세요~
Matetrial UI -> Row 커스텀 
아키텍처 조사 
```

## 2023-02-26-react조사목록

## 아키텍쳐

```
Atomic Design
Atomic Design은 웹 사이트나 어플리케이션의 디자인을 재사용 가능한 독립적인 구성 요소로 분해하는 디자인 패턴입니다. Atomic Design은 디자인을 분해하고 이를 구성하는 작은 구성 요소를 설명하는 아토믹 디자인 시스템을 구축하는 방식으로 작동합니다.

Component-Driven Design
Component-Driven Design은 Atomic Design과 비슷한 개념이지만, Atomic Design과는 달리 컴포넌트를 기반으로 하며, 컴포넌트의 재사용성과 가독성을 강조합니다. 이 방법은 React와 같은 컴포넌트 중심의 프레임워크에서 더욱 효과적입니다.

Material Design
Material Design은 Google에서 만든 디자인 시스템으로, 머터리얼 디자인이라고도 합니다. 머터리얼 디자인은 재사용 가능한 디자인 패턴, 컴포넌트 및 가이드라인을 제공하여 일관성 있는 디자인을 제공합니다.

Fluent Design
Fluent Design은 마이크로소프트에서 만든 디자인 시스템으로, 마이크로소프트의 제품군에서 사용되는 통일된 디자인 시스템입니다. Fluent Design은 애니메이션과 이펙트를 중심으로 한 사용자 경험을 제공합니다.

위의 디자인 구조는 대표적인 방법이며, 프로젝트의 특성에 따라 다양한 디자인 구조를 선택할 수 있습니다. 선택한 디자인 구조를 프로젝트 전반에 걸쳐 일관성 있게 적용하여 개발의 생산성을 높이는 것이 중요합니다.
```

- CDD

  ```
  Component-Driven Design(CDD)은 UI를 구축하는 방식 중 하나로, 컴포넌트를 기반으로 UI를 설계하고 개발하는 방법론입니다.
  
  CDD는 UI의 레이아웃, 기능, 상태 등을 작은 단위의 컴포넌트로 분해하고, 이를 다시 조합하여 큰 단위의 컴포넌트를 만들어나가는 방식으로 UI를 구성합니다. 이를 통해 재사용성과 유지보수성을 높일 수 있습니다.
  
  또한 CDD는 컴포넌트를 중심으로 한 UI 설계를 지향하기 때문에, 개발자와 디자이너 간의 협업을 용이하게 만들어줍니다. 디자이너는 컴포넌트 라이브러리를 활용하여 UI 요소를 디자인하고, 개발자는 이를 바탕으로 실제 UI를 개발합니다.
  
  CDD를 활용하기 위해서는, 먼저 컴포넌트의 특성과 역할을 파악하고, 이를 기반으로 컴포넌트를 재사용 가능하게 만드는 작업이 필요합니다. 또한 스토리북과 같은 툴을 활용하여 컴포넌트를 미리 시각화하고 테스트하는 것이 좋습니다.
  
  요약하면, CDD는 UI 설계를 컴포넌트 중심으로 하는 방법론으로, 재사용성과 유지보수성을 높이고 개발자와 디자이너 간의 협업을 용이하게 만들어줍니다. 이를 위해서는 컴포넌트의 특성과 역할을 파악하고, 재사용 가능하게 만드는 작업이 필요합니다.
  ```

## Feature 디자인으로 구성

```
src/
├── features/
│   ├── authentication/
│   │   ├── components/
│   │   │   ├── LoginForm/
│   │   │   │   ├── index.tsx
│   │   │   │   ├── LoginForm.spec.tsx
│   │   │   │   └── styles.ts
│   │   │   └── ...
│   │   ├── pages/
│   │   │   ├── LoginPage/
│   │   │   │   ├── index.tsx
│   │   │   │   ├── LoginPage.spec.tsx
│   │   │   │   └── styles.ts
│   │   │   └── ...
│   │   ├── utils/
│   │   │   ├── auth.ts
│   │   │   └── ...
│   │   └── index.ts
│   ├── dashboard/
│   │   ├── components/
│   │   │   ├── DashboardCard/
│   │   │   │   ├── index.tsx
│   │   │   │   ├── DashboardCard.spec.tsx
│   │   │   │   └── styles.ts
│   │   │   └── ...
│   │   ├── pages/
│   │   │   ├── DashboardPage/
│   │   │   │   ├── index.tsx
│   │   │   │   ├── DashboardPage.spec.tsx
│   │   │   │   └── styles.ts
│   │   │   └── ...
│   │   ├── utils/
│   │   │   ├── api.ts
│   │   │   └── ...
│   │   └── index.ts
│   └── ...
├── shared/
│   ├── components/
│   │   ├── Button/
│   │   │   ├── index.tsx
│   │   │   ├── Button.spec.tsx
│   │   │   └── styles.ts
│   │   └── ...
│   ├── styles/
│   │   ├── globalStyles.ts
│   │   └── ...
│   └── ...
├── App.tsx
├── index.tsx
└── ...

```

```
Feature Design 패턴은 기능(Feature)별로 구성된 폴더 구조로, 해당 기능에 필요한 컴포넌트, 스타일, 페이지, 유틸리티 등이 모두 포함되어 있습니다. 각 폴더는 독립적인 공간으로서 개별적인 상태(state), 기능(functionality), 유틸리티(utility) 등을 가지고 있으며, 이들을 조합하여 전체 애플리케이션을 구성합니다.

아래는 Feature Design 패턴의 폴더 구조와 간단한 예제입니다.
```



## Zustand store 변경 감지 hook

```js
//js
import create from "zustand";

const useStore = create((set)=>({
	myValue: '';
  setMyValue: (newValue) => set({myValue: newValue}),
}));

function useStoreChange(select){
  const [state, setState] = useState(selector());
  
  const unsubscribe = useState.subscribe(
  (newState) => {
    const selectedState = selector(newState);
    if(selectedState !== state){
      setState(selectedState);
    }
  },
    selector,
  );
  
  useEffect(()=>{
    return () => unsubscribe();
  },[unsubscribe]);
  
  retrun state;
}

//ts
import create, {State} from 'zustand';
import {useEffect, useState} from 'react';

interface Store{
  myValue: string;
  setMyValue: (newValue: string) => void;
}

const useStore = create<Store>((set)=>({
  myValue: '',
  setMyValue: (newValue)=>set({myValue: newValue}),
}))

export function useStoreChange<T>(
):T{
  const [state, setState] = useState<T>(()=>selector(useStore.getState()));
  
  useEffect(()=>{
    const unsubscribe = useStore.subscribe(
    (newState)=>{
      const selectedState = selector(newState);
      if(selectedState !== state){
				setState(selectedState);
      }
    },
     selector,
    );
    return () => unsubscribe();
  },[selector]);
  return state;
}
```

## hook 사용하는 예시

```js
//js
import {useStore} from './useStore';
import {useStoreChange} from './useStoreChange';

export MyComponent(){
  const myValue = useStoreChange((state)=>state.myValue);
  const setMyValue = useStore((state)=>state.setMyValue);
  
  const handleInputChange= (event) =>{
    setMyValue(event.target.value);
  };
  
  return(
    <div>
    	<input type="text" value={myValue} onChange={handleInputCount}></input>
			<p>My Value: {myValue}</p>
    </div>
  );
}

//ts
import {useStore} from './useStore';
import useStoreChange from './useStoreChange';

export function MyComponent(){
	const myValue = useStoreChange((state)=> state.myValue);
  const setMyValue = useStore((state)=>state.setMyValue);
  
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>)=>{
		setMyValue(event.target.value);
  };
  
  return (
  <div>
    <input type="text" value={myValue} onChange={handleInputChange}></input>
		<p>My Value: {myValue}</p>
  </div>
  )
}
```

## object 변경해주는 change Hook 만들기

```ts

```

